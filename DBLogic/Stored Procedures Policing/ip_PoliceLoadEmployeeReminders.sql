-----------------------------------------------------------------------------------------------------------------------------
-- Creation of ip_PoliceLoadEmployeeReminders
-----------------------------------------------------------------------------------------------------------------------------
if exists (select * from sysobjects where id = object_id(N'[dbo].[ip_PoliceLoadEmployeeReminders]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
begin
	print '**** Drop procedure dbo.ip_PoliceLoadEmployeeReminders.'
	drop procedure dbo.ip_PoliceLoadEmployeeReminders
end
print '**** Creating procedure dbo.ip_PoliceLoadEmployeeReminders...'
print ''
go

set QUOTED_IDENTIFIER off
go
set ANSI_NULLS on
go

create procedure dbo.ip_PoliceLoadEmployeeReminders 
			@pnDebugFlag	tinyint
as
-- PROCEDURE :	ip_PoliceLoadEmployeeReminders
-- VERSION :	21
-- DESCRIPTION:	Inserts or updates reminders into the EMPLOYEEREMINDER table

-- MODIFICATION
-- Date		Who	SQA	Version
-- ====         ===	=== 	=======
-- 27/06/2001	MF			Procedure created
-- 25/05/2003	MF			Only load reminders for Cases that have not been marked as being in error. 
-- 13/06/2003	MF	8905		Load Employee Reminders as long as the Case has not been marked in error.
--					A Left Join is required to allow for the fact that the Case does not have to 
--					exist on the #TEMPCASES table.
-- 28 Jul 2003	MF		10	Standardise version number
-- 22 Oct 2003	MF	9371	11	Reminders are not being loaded if the Name to receive the reminder is not 
--					an employee.
--
-- 14 May 2004	MF	10033	12	Ensure the HOLDUNTILDATE is considered so that an existing Reminder is not
--					updated until any HOLDUNTILDATE has been reached.
-- 23 Feb 2007	MF	14431	13	Clear out the HOLDUNTILDATE once the date is reached.
-- 31 May 2007	MF	14812	14	Load all CASEEVENTS into TEMPCASEEVENT to improve performance.
-- 09 Feb 2009	MF	17370	15	Only insert Reminders for Cases if the Status allows reminders, the Case Event
--					is due, and an Open Action that the Event belongs to exists and is open.
-- 12 May 2009	vql	17404	16	Allow recording of ad hoc reminders against names, insert alert NAMENO into EMPLOYEEREMINDER table.
-- 20 Oct 2010	AT	RFC7272	17	Extended length of ALERTMESSAGE columns.
-- 01 Nov 2010	MF	18494	18	Reminders generated by an Alert may be attached to an Event that has occurred as this Event is what 
--					triggers the reminder.
-- 05 Jan 2010	MF	19302	19	A site control will determine if the On Hold Date for new future reminders will be set to the date of the
--					reminder.
-- 20 Apr 2011	MF	RFC10333 20	Reminders generated from an ALERT need to carry a reference to the EMPLOYEENO of the ALERT.
-- 14 Nov 2018  AV  75198/DR-45358	21   Date conversion errors when creating cases and opening names in Chinese DB

set nocount on

declare @ErrorCode	int
declare @bSetOnHoldDate	bit
declare	@sSQLString	nvarchar(max)

-- Initialise the errorcode and then set it after each SQL Statement

Set @ErrorCode = 0

If @ErrorCode=0
Begin
	-----------------------------------------
	-- SQA19302
	-- Get the site control to determine if
	-- reminders should have the On Hold Date
	-- set at the point of creation of the 
	-- reminder.
	-----------------------------------------
	Select @bSetOnHoldDate=COLBOOLEAN
	from SITECONTROL
	where CONTROLID='Policing Reminders On Hold'

	Set @ErrorCode=@@Error
End

-- Delete any potentially duplicate Reminders from the #TEMPEMPLOYEEREMINDER table
-- This cannot be handled with a DISTINCT clause because of the UniqueId that is require
-- to help generate a unique primary key.

If @ErrorCode=0
Begin
	Set @sSQLString="
	delete #TEMPEMPLOYEEREMINDER
	from #TEMPEMPLOYEEREMINDER T
	where exists
	(select * from #TEMPEMPLOYEEREMINDER T1
	 where	T1.NAMENO=T.NAMENO
	 and (T1.CASEID    =T.CASEID    or (T1.CASEID    is null and T.CASEID    is null))
	 and (T1.EVENTNO   =T.EVENTNO   or (T1.EVENTNO   is null and T.EVENTNO   is null))
	 and (T1.CYCLENO   =T.CYCLENO   or (T1.CYCLENO   is null and T.CYCLENO   is null))
 	 and (T1.REFERENCE =T.REFERENCE or (T1.REFERENCE is null and T.REFERENCE is null))
	 and  T1.SEQUENCENO=T.SEQUENCENO
	 and  T1.UNIQUEID > T.UNIQUEID)"

	exec @ErrorCode=sp_executesql @sSQLString
End

-- Update the EMPLOYEEREMINDER that already exist

if @ErrorCode=0
Begin
	Set @sSQLString="
	update	EMPLOYEEREMINDER
	set	DUEDATE		= T.DUEDATE,
		REMINDERDATE	= T.REMINDERDATE,
		READFLAG	= T.READFLAG,
		SOURCE		= T.SOURCE,
		DATEUPDATED	= getdate(),
		SHORTMESSAGE	= T.SHORTMESSAGE,
		LONGMESSAGE		= T.LONGMESSAGE,
		HOLDUNTILDATE	= NULL,	-- SQA14431
		NAMENO		= T.ALERTNAMENO
	from	EMPLOYEEREMINDER E
	join	#TEMPEMPLOYEEREMINDER T	on ( T.NAMENO=E.EMPLOYEENO
					and (T.CASEID=E.CASEID       or (T.CASEID    is null and E.CASEID    is null))
					and (T.EVENTNO=E.EVENTNO     or (T.EVENTNO   is null and E.EVENTNO   is null))
					and (T.CYCLENO=E.CYCLENO     or (T.CYCLENO   is null and E.CYCLENO   is null))
					and (T.REFERENCE=E.REFERENCE or (T.REFERENCE is null and E.REFERENCE is null))
					and  T.SEQUENCENO=E.SEQUENCENO)
	left join #TEMPCASES TC		on (TC.CASEID=E.CASEID)
	where TC.ERRORFOUND is null
	and (E.HOLDUNTILDATE is null OR E.HOLDUNTILDATE<=T.REMINDERDATE)" -- SQA10033

	exec @ErrorCode=sp_executesql @sSQLString
end

-- Insert new EMPLOYEEREMINDER that do not already exist

if @ErrorCode=0
Begin
	Set @sSQLString="
	insert into EMPLOYEEREMINDER (	EMPLOYEENO, MESSAGESEQ, CASEID, REFERENCE, EVENTNO, CYCLENO, DUEDATE,
					REMINDERDATE, READFLAG, SOURCE, DATEUPDATED,
 					SHORTMESSAGE, LONGMESSAGE, ALERTNAMENO, SEQUENCENO, NAMENO, HOLDUNTILDATE)
	select	distinct T.NAMENO, dateadd(ms, T.UNIQUEID, getdate()), T.CASEID, T.REFERENCE, T.EVENTNO, T.CYCLENO, T.DUEDATE,
		T.REMINDERDATE, T.READFLAG, T.SOURCE, getdate(),
		T.SHORTMESSAGE, T.LONGMESSAGE, T.FROMEMPLOYEENO, T.SEQUENCENO, T.ALERTNAMENO, 
		CASE WHEN(@bSetOnHoldDate=1 AND T.REMINDERDATE>getdate()) THEN T.REMINDERDATE ELSE NULL END	--SQA19302			
	from	#TEMPEMPLOYEEREMINDER T
	left join EMPLOYEEREMINDER E1 on
				   ( E1.EMPLOYEENO=T.NAMENO
	 			and (E1.CASEID    =T.CASEID    or (E1.CASEID    is null and T.CASEID    is null))
	 			and (E1.EVENTNO   =T.EVENTNO   or (E1.EVENTNO   is null and T.EVENTNO   is null))
	 			and (E1.CYCLENO   =T.CYCLENO   or (E1.CYCLENO   is null and T.CYCLENO   is null))
	 			and (E1.REFERENCE =T.REFERENCE or (E1.REFERENCE is null and T.REFERENCE is null))
	 			and  E1.SEQUENCENO=T.SEQUENCENO)
	left join #TEMPCASES TC	on (TC.CASEID=T.CASEID)
	left join STATUS S	on (S.STATUSCODE=TC.STATUSCODE)
	left join CASEEVENT CE	on (CE.CASEID =T.CASEID
				and CE.EVENTNO=T.EVENTNO
				and CE.CYCLE  =T.CYCLENO)
	Where E1.EMPLOYEENO is null
	and   TC.ERRORFOUND is null
	and  (TC.STATUSCODE is null OR S.REMINDERSALLOWED=1)			-- Status must allow reminders
	and  (T.EVENTNO     is null OR T.SOURCE=1 OR CE.OCCURREDFLAG=0)		-- Due date exists OR Generated by a User Alert
	and  (T.EVENTNO     is null OR T.SOURCE=1
				    OR exists (	select 1 from OPENACTION OA	-- Action is Open
						join EVENTCONTROL EC	on (EC.CRITERIANO=OA.CRITERIANO
									and EC.EVENTNO=T.EVENTNO)
						join ACTIONS AN		on (AN.ACTION=OA.ACTION)
						where OA.CASEID=T.CASEID
						and OA.POLICEEVENTS=1
						and ((AN.NUMCYCLESALLOWED>1 and OA.CYCLE=T.CYCLENO)
						 or   AN.NUMCYCLESALLOWED=1)))"

	exec @ErrorCode=sp_executesql @sSQLString,
					N'@bSetOnHoldDate	bit',
					  @bSetOnHoldDate=@bSetOnHoldDate
end

If  @pnDebugFlag>0 
and @ErrorCode=0
Begin
	declare @sTimeStamp	nvarchar(24)
	set 	@sTimeStamp=convert(nvarchar,getdate(),126)
	RAISERROR ('%s ip_PoliceLoadEmployeeReminders',0,1,@sTimeStamp ) with NOWAIT
End

return @ErrorCode
go

grant execute on dbo.ip_PoliceLoadEmployeeReminders  to public
go
