-----------------------------------------------------------------------------------------------------------------------------
-- Creation of cs_GenerateNextSequence
-----------------------------------------------------------------------------------------------------------------------------
If exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[cs_GenerateNextSequence]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
Begin
	Print '**** Drop Stored Procedure dbo.cs_GenerateNextSequence.'
 	Drop procedure [dbo].[cs_GenerateNextSequence]
End
Print '**** Creating Stored Procedure dbo.cs_GenerateNextSequence...'
Print ''
GO

SET QUOTED_IDENTIFIER OFF


GO

CREATE PROCEDURE dbo.cs_GenerateNextSequence
(
 	@psGeneratedSequence 	nvarchar(12)	= null output,
 	@psRomanNumeral		nvarchar(12)	= null output,  -- Only returned when Roman Numeral sequence required
 	@pnUserIdentityId 	int,  		-- Mandatory
 	@psPartialCaseReference	nvarchar(30),	-- Mandatory	Is assembled from all of the Segments, but substituting "%" for the Sequence to be generated.
 	@pnSequenceType		int,		-- Mandatory
 	@psStemSegment		nvarchar(30)	-- Mandatory	Stem segment value.
)
as
-- PROCEDURE: cs_GenerateNextSequence
-- VERSION: 10
-- SCOPE: CPA.net
-- DESCRIPTION: Generate Next Sequence for a Case.
-- COPYRIGHT:	Copyright 1993 - 2005 CPA Software Solutions (Australia) Pty Limited
-- MODIFICATIONS :
-- Date		Who	Change	Version	Description
-- ------------	-------	------	-------	----------------------------------------------- 
-- 01-Jul-2003  TM 		1 	Procedure created
-- 20-Sep-2004	MF	10297  	2	Provide for a Roman Numeral sequence
-- 24-Sep-2204	MF	10698  	3	Provide for a new sequence '01 Ascending',
-- 24-May-2005	TM	RFC1990	4	Increase @psStemSegment from 12 to 30 characters.
-- 30-May-2005	JD	11268	5	Added a filter to remove the prefix 'R' in the Roman Numerals section.
-- 13-Jul-2005	AT	SQA7463	6	Modified to refer to Sequence Type Options TABLECODES.
-- 10-Nov-2006	JD	12068	7	Added a new sequence Z&Descending.
-- 28 May 2007	vql	14774	8	Add new 000, 001, 0000, 0001 sequence types.
-- 27 Mar 2008	vql	15944	9	SQL Error Using 00 Ascending Stem In IRN Generation.
-- 20 Aug 2010	vql	18960	10	SQL Error Using null Ascending Stem In IRN Generation


SET NOCOUNT Off
SET CONCAT_NULL_YIELDS_NULL OFF


declare @sTemporaryIRN			nvarchar(30)	-- Is used to hold IRN value before it is checked for duplicates in CASES.IRN.
declare @sGeneratedSequence		nvarchar(12)	-- Sequence generated by the cs_GenerateNextSequence stored procedure.
declare @sStemSegment   		nvarchar(30) 	-- Stem value (SEGMENTVALUE where ISSTEM = 1 and there is no "Parent StemSequence" segment). 
declare @sMaxStem			nvarchar(30)	-- The max Stem from the Cases.Stem where IRN is like PartialCaseReference with a Sequence of the same format.
declare @bLastStem   			bit  		-- If the Last Stem found on the Case with the Last Sequence then @bLastStem = 1, else 0.
declare @sLastSequenceNo  		nvarchar(4)
declare @sFirstGeneratedSequence 	nvarchar(4) 	-- Next Sequence Number after last sequence generated - is a flag to check if all of the available Sequence values have already been utilised. 
declare @sLastSequenceNoBefore  	nvarchar(4) 	-- Last Sequence Number the beginning of the WHILE loop - only used in 'Nul+1 Ascending' and 'Nul+A&Ascending' to avoid infinite loop.

declare @sSQLString			nvarchar(4000)
declare @sSQLFilter 			nvarchar(4000)	-- Holds dynamically created filtering conditions for @sMaxStem selection. 

Declare @sAlertXML 			nvarchar(400)

Declare @nErrorCode 			int

Set     @nErrorCode 			= 0
Set 	@psPartialCaseReference		= UPPER(@psPartialCaseReference)

Declare @n00Ascending Int
Declare @n01Ascending Int
Declare @n1Ascending Int
Declare @nAAscending Int
Declare @nCheckDigit Int
Declare @nNul1Ascending Int
Declare @nNulAAscending Int
Declare @nRomanNumeral Int
Declare @nZDescending Int
Declare @n000Ascending int
Declare @n001Ascending int
Declare @n0000Ascending int
Declare @n0001Ascending int

Set @nZDescending = 1399
Set @n00Ascending = 1400
Set @n01Ascending = 1401
Set @n1Ascending = 1402
Set @nAAscending = 1403
Set @nCheckDigit = 1404
Set @nNul1Ascending = 1405
Set @nNulAAscending = 1406
Set @nRomanNumeral = 1407
Set @n000Ascending = 1468
Set @n001Ascending = 1469
Set @n0000Ascending = 1470
Set @n0001Ascending = 1471


-- '00 Ascending' 
-- '01 Ascending' Sequence

If @nErrorCode = 0
and @pnSequenceType in (@n00Ascending,@n01Ascending)
Begin
	-- Get the max Stem from the Cases.Stem where IRN is like PartialCaseReference
	-- with a Sequence of the same format.

	-- If @psStemSegment is not null then there is a "Stem" Segment so look for the
	-- max Stem first and then for the max Sequence else look just for the max Sequence.

	If @psStemSegment is null
	Begin
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)=1"
	End
	Else
	Begin
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)>1"
	End

	Set @sSQLString =
			"Select @sMaxStem = max(C1.STEM)
     			from CASES C1  
			join CASES C2 on (C1.CASEID=C2.CASEID)" 
			+ @sSQLFilter

	If @pnSequenceType=@n00Ascending
	Begin
		-- Ensure that extracted Sequence is between the required range of 0 and 99
		Set @sSQLString=@sSQLString+"
			and ((CAST(( SUBSTRING(C2.STEM,(PATINDEX('%~[0-9][0-9]', C2.STEM)+1), 2) ) as smallint) between 0 and 99))
    			where C1.IRN like @psPartialCaseReference"
	End
	Else Begin
		-- Ensure that extracted Sequence is between the required range of 1 and 99
		Set @sSQLString=@sSQLString+"
			and ((CAST(( SUBSTRING(C2.STEM,(PATINDEX('%~[0-9][0-9]', C2.STEM)+1), 2) ) as smallint) between 1 and 99))
    			where C1.IRN like @psPartialCaseReference"
	End

	Set @sSQLString=@sSQLString+"
			-- Exclude any Sequences containing characters or numbers that are not 
			-- the values from 01 to 99.

			and ( ASCII(LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+1), 12), 1)) between 48 and 57 ) and (( ASCII(LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+2), 12), 1)) between 48 and 57 ) or ( LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+2), 12), 1) = ''))

			-- Filter out any Sequences which length is not equal to two.			

    			and (LEN( SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+1), 10) ) = 2)" 


	exec @nErrorCode=sp_executesql @sSQLString, 
    				 N'@sMaxStem			nvarchar(30)	 OUTPUT,
       		  		   @psPartialCaseReference	nvarchar(30),
				   @psStemSegment		nvarchar(30)',
       		   		   @sMaxStem  			=@sMaxStem 	 OUTPUT,
       		   		   @psPartialCaseReference     	=@psPartialCaseReference,
				   @psStemSegment		=@psStemSegment
 
	-- Get the Last Sequence of previously saved Case and generate the Next Sequence.
		
   	If @nErrorCode = 0
   	Begin
		-- The Last Sequence is found in the Cases.Stem column of previously saved Cases
		-- (already extracted and concatenated at the end of @sMaxStem).
		
		Set @sLastSequenceNo = SUBSTRING(@sMaxStem,(CHARINDEX('~', @sMaxStem)+1), 2) 

		-- The Next Sequence is loaded into the @sLastSequenceNo variable.
		
		If @pnSequenceType=@n00Ascending
			Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo >= '99' OR @sLastSequenceNo IS NULL) then '00'
	      				       	    ELSE REPLICATE ('0', 2-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(2))
	      				       END 
		Else
			Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo >= '99' OR @sLastSequenceNo IS NULL) then '01'
	      				       	    ELSE REPLICATE ('0', 2-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(2))
	      				       END 

		-- Use @sFirstGeneratedSequenceis as a flag to check if all of the available Sequence values have already been utilised.

		Set @sFirstGeneratedSequence = @sLastSequenceNo

		-- Assemble the TemporaryIRN to check for duplicates in CASES.IRN.
 
		Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)
   	End
   		
	-- Generate Next Sequence until the unique value is found, 
	-- wrapping back to the beginning of the sequence range as necessary.
	
   	While @nErrorCode = 0 
	and exists(Select * from CASES where IRN = @sTemporaryIRN)  
   	Begin
    		Set @sLastSequenceNo = CASE WHEN @sLastSequenceNo >= '99' then '00'
       					    ELSE REPLICATE ('0', 2-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(2))
       				       END 
    		
		-- If all of the available Sequence values have already been utilised then raise an error.

		If @nErrorCode = 0
		and @sLastSequenceNo = @sFirstGeneratedSequence
		Begin
     			Set @sAlertXML = dbo.fn_GetAlertXML('CS34', 'Cannot generate Case Reference. All the Sequence values are in use.',
     							null, null, null, null, null)
     			RAISERROR(@sAlertXML, 14, 1)

     			Set @nErrorCode = @@ERROR
			BREAK
    		End 
			
		-- Insert new Generated Sequence in the @sTemporaryIRN to check for duplicates in CASES.IRN. 

    		If @nErrorCode = 0
    		Begin  
     			Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)   
    		End
   		Set @nErrorCode = @@ERROR
   	End
     			
	-- Load new unique Sequence format. 

	If @nErrorCode = 0
   	Begin
     		Set @psGeneratedSequence = @sLastSequenceNo
       	End
End

-- '000 Ascending' 
-- '001 Ascending' Sequence
If @nErrorCode = 0
and @pnSequenceType in (@n000Ascending,@n001Ascending)
Begin
	-- Get the max Stem from the Cases.Stem where IRN is like PartialCaseReference
	-- with a Sequence of the same format.

	-- If @psStemSegment is not null then there is a "Stem" Segment so look for the
	-- max Stem first and then for the max Sequence else look just for the max Sequence.

	If @psStemSegment is null
	Begin
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)=1"
	End
	Else
	Begin
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)>1"
	End

	Set @sSQLString =
			"Select @sMaxStem = max(C1.STEM)
     			from CASES C1  
			join CASES C2 on (C1.CASEID=C2.CASEID)" 
			+ @sSQLFilter

	If @pnSequenceType=@n000Ascending
	Begin
		-- Ensure that extracted Sequence is between the required range of 0 and 999
		Set @sSQLString=@sSQLString+"
			and ((CAST(( SUBSTRING(C2.STEM,(PATINDEX('%~[0-9][0-9][0-9]', C2.STEM)+1), 3) ) as smallint) between 0 and 999))
    			where C1.IRN like @psPartialCaseReference"
	End
	Else Begin
		-- Ensure that extracted Sequence is between the required range of 1 and 999
		Set @sSQLString=@sSQLString+"
			and ((CAST(( SUBSTRING(C2.STEM,(PATINDEX('%~[0-9][0-9][0-9]', C2.STEM)+1), 3) ) as smallint) between 1 and 999))
    			where C1.IRN like @psPartialCaseReference"
	End

	Set @sSQLString=@sSQLString+"
			-- Exclude any Sequences containing characters or numbers that are not 
			-- the values from 01 to 999.

			and ( ASCII(LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+1), 12), 1)) between 48 and 57 ) and (( ASCII(LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+2), 12), 1)) between 48 and 57 ) or ( LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+2), 12), 1) = ''))

			-- Filter out any Sequences which length is not equal to three.			

    			and (LEN( SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+1), 10) ) = 3)" 


	exec @nErrorCode=sp_executesql @sSQLString, 
    				 N'@sMaxStem			nvarchar(30)	 OUTPUT,
       		  		   @psPartialCaseReference	nvarchar(30),
				   @psStemSegment		nvarchar(30)',
       		   		   @sMaxStem  			=@sMaxStem 	 OUTPUT,
       		   		   @psPartialCaseReference     	=@psPartialCaseReference,
				   @psStemSegment		=@psStemSegment
 
	-- Get the Last Sequence of previously saved Case and generate the Next Sequence.
		
   	If @nErrorCode = 0
   	Begin
		-- The Last Sequence is found in the Cases.Stem column of previously saved Cases
		-- (already extracted and concatenated at the end of @sMaxStem).
		Set @sLastSequenceNo = SUBSTRING(@sMaxStem,(CHARINDEX('~', @sMaxStem)+1), 3)

		-- The Next Sequence is loaded into the @sLastSequenceNo variable.
		If @pnSequenceType=@n000Ascending
			Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo >= '999' OR @sLastSequenceNo IS NULL) then '000'
	      				       	    ELSE REPLICATE ('0', 3-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(3))
	      				       END 
		Else
			Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo >= '999' OR @sLastSequenceNo IS NULL) then '001'
	      				       	    ELSE REPLICATE ('0', 3-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(3))
	      				       END 

		-- Use @sFirstGeneratedSequenceis as a flag to check if all of the available Sequence values have already been utilised.

		Set @sFirstGeneratedSequence = @sLastSequenceNo

		-- Assemble the TemporaryIRN to check for duplicates in CASES.IRN.
 
		Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)
   	End
   		
	-- Generate Next Sequence until the unique value is found, 
	-- wrapping back to the beginning of the sequence range as necessary.
	
   	While @nErrorCode = 0 
	and exists(Select * from CASES where IRN = @sTemporaryIRN)  
   	Begin
    		Set @sLastSequenceNo = CASE WHEN @sLastSequenceNo >= '999' then '000'
       					    ELSE REPLICATE ('0', 3-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(3))
       				       END 
    		
		-- If all of the available Sequence values have already been utilised then raise an error.

		If @nErrorCode = 0
		and @sLastSequenceNo = @sFirstGeneratedSequence
		Begin
     			Set @sAlertXML = dbo.fn_GetAlertXML('CS34', 'Cannot generate Case Reference. All the Sequence values are in use.',
     							null, null, null, null, null)
     			RAISERROR(@sAlertXML, 14, 1)
     			Set @nErrorCode = @@ERROR
			BREAK
    		End 
			
		-- Insert new Generated Sequence in the @sTemporaryIRN to check for duplicates in CASES.IRN. 

    		If @nErrorCode = 0
    		Begin  
     			Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)   
    		End
   		Set @nErrorCode = @@ERROR
   	End
     			
	-- Load new unique Sequence format. 

	If @nErrorCode = 0
   	Begin
     		Set @psGeneratedSequence = @sLastSequenceNo
       	End
End

-- '0000 Ascending' 
-- '0001 Ascending' Sequence
If @nErrorCode = 0
and @pnSequenceType in (@n0000Ascending,@n0001Ascending)
Begin
	-- Get the max Stem from the Cases.Stem where IRN is like PartialCaseReference
	-- with a Sequence of the same format.

	-- If @psStemSegment is not null then there is a "Stem" Segment so look for the
	-- max Stem first and then for the max Sequence else look just for the max Sequence.

	If @psStemSegment is null
	Begin
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)=1"
	End
	Else
	Begin
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)>1"
	End

	Set @sSQLString =
			"Select @sMaxStem = max(C1.STEM)
     			from CASES C1  
			join CASES C2 on (C1.CASEID=C2.CASEID)" 
			+ @sSQLFilter

	If @pnSequenceType=@n0000Ascending
	Begin
		-- Ensure that extracted Sequence is between the required range of 0 and 9999
		Set @sSQLString=@sSQLString+"
			and ((CAST(( SUBSTRING(C2.STEM,(PATINDEX('%~[0-9][0-9][0-9][0-9]', C2.STEM)+1), 4) ) as smallint) between 0 and 9999))
    			where C1.IRN like @psPartialCaseReference"
	End
	Else Begin
		-- Ensure that extracted Sequence is between the required range of 1 and 9999
		Set @sSQLString=@sSQLString+"
			and ((CAST(( SUBSTRING(C2.STEM,(PATINDEX('%~[0-9][0-9][0-9][0-9]', C2.STEM)+1), 4) ) as smallint) between 1 and 9999))
    			where C1.IRN like @psPartialCaseReference"
	End

	Set @sSQLString=@sSQLString+"
			-- Exclude any Sequences containing characters or numbers that are not 
			-- the values from 01 to 9999.

			and ( ASCII(LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+1), 12), 1)) between 48 and 57 ) and (( ASCII(LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+2), 12), 1)) between 48 and 57 ) or ( LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+2), 12), 1) = ''))

			-- Filter out any Sequences which length is not equal to three.			

    			and (LEN( SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+1), 10) ) = 4)" 


	exec @nErrorCode=sp_executesql @sSQLString, 
    				 N'@sMaxStem			nvarchar(30)	 OUTPUT,
       		  		   @psPartialCaseReference	nvarchar(30),
				   @psStemSegment		nvarchar(30)',
       		   		   @sMaxStem  			=@sMaxStem 	 OUTPUT,
       		   		   @psPartialCaseReference     	=@psPartialCaseReference,
				   @psStemSegment		=@psStemSegment
 
	-- Get the Last Sequence of previously saved Case and generate the Next Sequence.
		
   	If @nErrorCode = 0
   	Begin
		-- The Last Sequence is found in the Cases.Stem column of previously saved Cases
		-- (already extracted and concatenated at the end of @sMaxStem).
		Set @sLastSequenceNo = SUBSTRING(@sMaxStem,(CHARINDEX('~', @sMaxStem)+1), 4)

		-- The Next Sequence is loaded into the @sLastSequenceNo variable.
		If @pnSequenceType=@n0000Ascending
			Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo >= '9999' OR @sLastSequenceNo IS NULL) then '0000'
	      				       	    ELSE REPLICATE ('0', 4-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(4))
	      				       END 
		Else
			Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo >= '9999' OR @sLastSequenceNo IS NULL) then '0001'
	      				       	    ELSE REPLICATE ('0', 4-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(4))
	      				       END 

		-- Use @sFirstGeneratedSequenceis as a flag to check if all of the available Sequence values have already been utilised.

		Set @sFirstGeneratedSequence = @sLastSequenceNo

		-- Assemble the TemporaryIRN to check for duplicates in CASES.IRN.
 
		Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)
   	End
   		
	-- Generate Next Sequence until the unique value is found, 
	-- wrapping back to the beginning of the sequence range as necessary.
	
   	While @nErrorCode = 0 
	and exists(Select * from CASES where IRN = @sTemporaryIRN)  
   	Begin
    		Set @sLastSequenceNo = CASE WHEN @sLastSequenceNo >= '9999' then '0000'
       					    ELSE REPLICATE ('0', 4-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(4))
       				       END 
    		
		-- If all of the available Sequence values have already been utilised then raise an error.

		If @nErrorCode = 0
		and @sLastSequenceNo = @sFirstGeneratedSequence
		Begin
     			Set @sAlertXML = dbo.fn_GetAlertXML('CS34', 'Cannot generate Case Reference. All the Sequence values are in use.',
     							null, null, null, null, null)
     			RAISERROR(@sAlertXML, 14, 1)
     			Set @nErrorCode = @@ERROR
			BREAK
    		End 
			
		-- Insert new Generated Sequence in the @sTemporaryIRN to check for duplicates in CASES.IRN. 

    		If @nErrorCode = 0
    		Begin  
     			Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)   
    		End
   		Set @nErrorCode = @@ERROR
   	End
     			
	-- Load new unique Sequence format. 

	If @nErrorCode = 0
   	Begin
     		Set @psGeneratedSequence = @sLastSequenceNo
       	End
End

--Selecting maximum Stem from the CASES table for '1 Ascending', 'Nul+ 1Ascending' Sequences. 

If @nErrorCode = 0
and @pnSequenceType in (@n1Ascending, @nNul1Ascending)
Begin 
	-- Get the max Stem from the Cases.Stem where IRN is like PartialCaseReference
	-- with a Sequence of the same format.

	-- If @psStemSegment is not null then there is a "Stem" Segment so look for the 
	-- max Stem first and then for the max Sequence else just look for the max Sequence.
  
	If @psStemSegment is null
	Begin 
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)=1"
	End
	Else 
	Begin
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)>1"  
	End	

	Set @sSQLString =
			"Select @sMaxStem = max(C1.STEM)
     			from CASES C1 
			join CASES C2 on (C1.CASEID=C2.CASEID)" 
			+ @sSQLFilter +

			-- Ensure that extracted Sequence is between 1 and 99.

	     		"and (isnumeric( SUBSTRING(C2.STEM,(CHARINDEX('~', C2.STEM)+1), 2)) = 1)
	     		where  (C1.IRN like @psPartialCaseReference)

			-- Exclude any Sequences containing characters or numbers that are not 
			-- the values from 1 to 99.

	     		and ( ASCII(LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+1), 12), 1)) between 49 and 57 ) and (( ASCII(LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+2), 12), 1)) between 48 and 57 ) or ( LEFT(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+2), 12), 1) = ''))

			-- Filter out any Sequences which length is not between 1 and 2.	

	     		and (LEN( SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+1), 10) ) between 1 and 2)"


	exec @nErrorCode=sp_executesql @sSQLString, 
    				 N'@sMaxStem			nvarchar(30)	 OUTPUT,
       		  		   @psPartialCaseReference	nvarchar(30),
				   @psStemSegment		nvarchar(30)',
       		   		   @sMaxStem  			=@sMaxStem 	 OUTPUT,
       		   		   @psPartialCaseReference     	=@psPartialCaseReference,
				   @psStemSegment		=@psStemSegment	

	If @nErrorCode = 0
   	Begin
		-- The Last Sequence is found in the Cases.Stem column of previously saved Cases
		-- (already extracted and concatenated at the end of @sMaxStem).

    		Set @sLastSequenceNo = SUBSTRING(@sMaxStem,(CHARINDEX('~', @sMaxStem)+1), 2) 

		-- If the Last Stem exists (@bLastStem = 0) first value for 'Nul+ 1Ascending'
		-- and 'Nul+A&Ascending' is null otherwise it is 1 and A consequently.  

    		Set @bLastStem = CASE WHEN (CHARINDEX('~', @sMaxStem) = 1 ) OR (@sMaxStem IS NULL) THEN 0
            		      	      ELSE 1
            		         END 
   	End
End

-- '1 Ascending' Sequence. 

If @nErrorCode = 0
and @pnSequenceType = @n1Ascending
Begin
	-- The Next Sequence is loaded into the @sLastSequenceNo variable.

   	Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo >= '99' OR @sLastSequenceNo IS NULL) then '1'
     				    ELSE CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(2))
     			       END 
		
	-- Use @sFirstGeneratedSequenceis as a flag to check if all of the available Sequence values have already been utilised. 

	Set @sFirstGeneratedSequence = @sLastSequenceNo

	-- Assemble the @sTemporaryIRN to check for duplicates in CASES.IRN. 

        Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)

	-- Generate Next Sequence until the unique value is found, 
	-- wrapping back to the beginning of the sequence range as necessary.
      
    	While @nErrorCode = 0
	and exists(Select * from CASES where IRN = @sTemporaryIRN)
    	Begin
     		Set @sLastSequenceNo = CASE WHEN @sLastSequenceNo >= '99' then '1'
       				            ELSE CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(2))
        			       END 

		-- If all of the available Sequence values have already been utilised then raise an error.

     		If @nErrorCode = 0
		and @sLastSequenceNo = @sFirstGeneratedSequence 
     		Begin
      			Set @sAlertXML = dbo.fn_GetAlertXML('CS34', 'Cannot generate Case Reference.  All the Sequence values are in use.',
          						null, null, null, null, null)
      			RAISERROR(@sAlertXML, 14, 1)
     			Set @nErrorCode = @@ERROR
			BREAK
     		End 

		-- Insert new Generated Sequence in the @sTemporaryIRN to check for duplicates in CASES.IRN. 

     		If @nErrorCode = 0
    		Begin  
      			Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo )
     		End
    		Set @nErrorCode = @@ERROR
    	End

	-- Load new unique Sequence of '1 Ascending' format. 

  	If @nErrorCode = 0
   	Begin
    		Set @psGeneratedSequence = @sLastSequenceNo
   	End
End

-- 'Nul+ 1Ascending' Sequence.

If @nErrorCode = 0
and @pnSequenceType = @nNul1Ascending
Begin
	-- The Next Sequence is loaded into the @sLastSequenceNo variable. 

   	Set @sLastSequenceNo = CASE WHEN ((@sLastSequenceNo >= '99') OR (@sLastSequenceNo IS NULL)) AND @bLastStem = 1 THEN 1
      				    WHEN ((@sLastSequenceNo >= '99') OR (@sLastSequenceNo IS NULL)) AND @bLastStem = 0 THEN NULL
      				    ELSE CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(2))
      			       END 

	-- Use @sFirstGeneratedSequenceis as a flag to check if all of the available Sequence values have already been utilised. 

 	Set @sFirstGeneratedSequence = @sLastSequenceNo

	-- If @sFirstGeneratedSequence is null then set it to '' so REPLACE function can handle it properly.
 
   	If @sFirstGeneratedSequence is null
   	Begin
    		Set @sFirstGeneratedSequence = ''
   	End
	
	-- Assemble the @sTemporaryIRN to check for duplicates in CASES.IRN.

        Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sFirstGeneratedSequence)
	
	-- Generate Next Sequence until the unique value is found, 
	-- wrapping back to the beginning of the sequence range as necessary.		

 	While @nErrorCode = 0
	and exists(Select * from CASES where IRN = @sTemporaryIRN)
   	Begin
		-- Store the initial @sLastSequenceNo value in @sLastSequenceNoBefore
		-- to be able to avoid infinite loop.  

    		Set @sLastSequenceNoBefore = @sLastSequenceNo  

  		Set @sLastSequenceNo = CASE WHEN ((@sLastSequenceNo >= '99') OR (@sLastSequenceNo IS NULL)) AND @bLastStem = 1 THEN 1
       					    WHEN ((@sLastSequenceNo >= '99') OR (@sLastSequenceNo IS NULL)) AND @bLastStem = 0 THEN NULL
       					    ELSE CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(2))
       				       END 

		-- Avoiding infinite loop that may occur when @sLastSequenceNo is null 
		-- and Last Stem does not exists (@bLastStem = 0).    

    		Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo is null) and (@sLastSequenceNoBefore is null) THEN '1'   
             				    ELSE  @sLastSequenceNo 
			               END 
				
		-- If @sLastSequenceNoAfter is null then set it to '' so it can be compared to 
		-- the @sFirstGeneratedSequence and REPLICATE function can handle it properly.      	
	
		If @sLastSequenceNo is null
     		Begin
      			Set @sLastSequenceNo = ''
     		End	

		-- If all of the available Sequence values have already been utilised then raise an error.
		
   		If @nErrorCode = 0 
		and @sLastSequenceNo = @sFirstGeneratedSequence 
    		Begin
     			Set @sAlertXML = dbo.fn_GetAlertXML('CS34', 'Cannot generate Case Reference.  All the Sequence values are in use.',
         						null, null, null, null, null)
     			RAISERROR(@sAlertXML, 14, 1)
     			Set @nErrorCode = @@ERROR
			BREAK
    		End 

   		If @nErrorCode = 0
    		Begin 
     			-- Assemble the @sTemporaryIRN to check for duplicates in CASES.IRN.

     			Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)
		End
   		Set @nErrorCode = @@ERROR
   	End
  
	-- Load new unique Sequence of 'Nul+ 1Ascending' format.
 
	If @nErrorCode = 0
  	Begin
  		Set @psGeneratedSequence = @sLastSequenceNo
  	End
End

-- Selecting maximum Stem form the CASES table for 'A&Ascending', 'Nul+A&Ascending' Sequence. 

If @nErrorCode = 0
and @pnSequenceType in (@nAAscending, @nNulAAscending)
Begin 
	-- Get the max Stem from the Cases.Stem where IRN is like PartialCaseReference
	-- with a Sequence of the same format.

	-- If @psStemSegment is not null then there is a "Stem" Segment so look for the 
	-- max Stem first, then for the max Sequence.
	
	If @psStemSegment is null
	Begin 
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)=1"
	End
	Else 
	Begin
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)>1"  
	End	

	Set @sSQLString=
   		"Select @sMaxStem = 
			CONVERT(NCHAR(30),
    			SUBSTRING(
    			MAX(

			-- Look for the Sequences with the max length first (so Sequence AA would be considered 
			-- being greater then Sequence B).			

			CAST(LEN(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+1), 2)) AS NCHAR(1)) +

			-- Concatenate the max Stem at the end to be able to extract the Last Sequence Generated.  

    			CAST(C1.STEM AS NCHAR(30))),2,30))
     			from CASES C1 
			join CASES C2 on (C1.CASEID=C2.CASEID)" 
			+ @sSQLFilter +
			"where (C1.IRN like @psPartialCaseReference)
			
			-- Ensure that extracted max Stem has Sequence which length is between 1 and 2.

	          	and ( LEN(SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+1), 10)) between 1 and 2 ) 

			-- Filter out any Sequences containing not only A to Z characters.  

	   		and (ASCII(LEFT(SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+1), 2), 1)) between 65 and 90) 
	   	        and (( (ASCII(LEFT(SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+2), 2), 1)) between 65 and 90)) or (LEFT(SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+2), 2), 1) = ''))"  

	exec @nErrorCode=sp_executesql @sSQLString, 
    	 			N'@sMaxStem			nvarchar(30)	 	OUTPUT,
       	  		  	  @psPartialCaseReference	nvarchar(30),
				  @psStemSegment		nvarchar(30)',
       	   		  	  @sMaxStem  			=@sMaxStem 		OUTPUT,
       	   		  	  @psPartialCaseReference      	=@psPartialCaseReference,
				  @psStemSegment		=@psStemSegment	

   	If @nErrorCode = 0
  	Begin
		-- The Last Sequence is found in the Cases.Stem column of previously saved Cases
		-- (already extracted and concatenated at the end of @sMaxStem).

    		Set @sLastSequenceNo = SUBSTRING(@sMaxStem,(CHARINDEX('~', @sMaxStem)+1), 2) 
		
		-- If the Last Stem does not exist (@bLastStem = 0) first value for 'Nul+ 1Ascending' 
		-- and 'Nul+A&Ascending' Sequences are null otherwise they are 1 and A consequently.  

    		Set @bLastStem = CASE WHEN (CHARINDEX('~', @sMaxStem) = 1 ) OR (@sMaxStem is null) THEN 0
            	      		      ELSE 1
            		         END 
   	
	End
End

-- 'A&Ascending' Sequence.

If @nErrorCode = 0
and @pnSequenceType = @nAAscending
Begin
	-- The Next Sequence is loaded into the @sLastSequenceNo variable. 

   	Set @sLastSequenceNo = CASE WHEN (ASCII(LEFT(@sLastSequenceNo, 1)) BETWEEN 65 AND 89) AND (LEN(@sLastSequenceNo) = 1) THEN CHAR(ASCII(@sLastSequenceNo)+1) 
      				    WHEN @sLastSequenceNo = 'Z'  THEN 'AA'
      				    WHEN (ASCII(RIGHT(@sLastSequenceNo, 1)) BETWEEN 65 AND 89) AND (LEN(@sLastSequenceNo) = 2) THEN LEFT(@sLastSequenceNo, 1) + CHAR(ASCII(RIGHT(@sLastSequenceNo, 1))+1) 
				    WHEN (ASCII(LEFT(@sLastSequenceNo, 1))  BETWEEN 65 AND 89) AND (ASCII(RIGHT(@sLastSequenceNo, 1)) = 90) THEN CHAR(ASCII(LEFT(@sLastSequenceNo, 1))+1) + 'A'  
				    WHEN (@sLastSequenceNo = 'ZZ' OR @sLastSequenceNo IS NULL) THEN 'A' 
      			       END 
    
	-- Use @sFirstGeneratedSequenceis as a flag to check if all of the available Sequence values have already been utilised. 

	Set @sFirstGeneratedSequence = @sLastSequenceNo

	-- Assemble the @sTemporaryIRN to check for duplicates in CASES.IRN.

        Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)
		
	-- Generate Next Sequence until the unique value is found, 
	-- wrapping back to the beginning of the sequence range as necessary.
	    
	While @nErrorCode = 0
	and exists(Select * from CASES where IRN = @sTemporaryIRN)
	Begin
		Set @sLastSequenceNo =  CASE WHEN (ASCII(LEFT (@sLastSequenceNo, 1)) BETWEEN 65 AND 89) AND (LEN(@sLastSequenceNo) = 1) THEN CHAR(ASCII(@sLastSequenceNo)+1) 
				             WHEN @sLastSequenceNo = 'Z'  THEN 'AA'
				             WHEN (ASCII(RIGHT(@sLastSequenceNo, 1)) BETWEEN 65 AND 89) AND (LEN(@sLastSequenceNo) = 2) THEN LEFT(@sLastSequenceNo, 1) + CHAR(ASCII(RIGHT(@sLastSequenceNo, 1))+1) 
				             WHEN (ASCII(LEFT(@sLastSequenceNo, 1))  BETWEEN 65 AND 89) AND (ASCII(RIGHT(@sLastSequenceNo, 1)) = 90) THEN CHAR(ASCII(LEFT(@sLastSequenceNo, 1))+1) + 'A'  
				             WHEN @sLastSequenceNo = 'ZZ' THEN 'A' 
      				        END

		-- If all of the available Sequence values have already been utilised then raise an error.

		If @nErrorCode = 0
		and @sLastSequenceNo = @sFirstGeneratedSequence 
		Begin
			Set @sAlertXML = dbo.fn_GetAlertXML('CS34', 'Cannot generate Case Reference.  All the Sequence values are in use.',
		         				null, null, null, null, null)
			RAISERROR(@sAlertXML, 14, 1)
		  	Set @nErrorCode = @@ERROR
			BREAK
		End 
			
		-- Insert new Generated Sequence in the TemporaryIRN to check for duplicates in CASES.IRN. 

     		If @nErrorCode = 0
     		Begin  
      			Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo )
     		End
	   	Set @nErrorCode = @@ERROR
	End
  		
	-- Load new unique Sequence of 'A&Ascending' format. 

   	If @nErrorCode = 0
   	Begin
   		Set @psGeneratedSequence = @sLastSequenceNo
  	End
End

-- 'Nul+A&Ascending' Sequence. 

If @nErrorCode = 0
and @pnSequenceType = @nNulAAscending
Begin
	-- The Next Sequence is loaded into the @sLastSequenceNo variable.
 	
   	Set @sLastSequenceNo = CASE WHEN (ASCII(LEFT (@sLastSequenceNo, 1)) BETWEEN 65 AND 89) AND (LEN(@sLastSequenceNo) = 1) THEN CHAR(ASCII(@sLastSequenceNo)+1) 
      				    WHEN @sLastSequenceNo = 'Z'  THEN 'AA'
      				    WHEN (ASCII(RIGHT(@sLastSequenceNo, 1)) BETWEEN 65 AND 89) AND (LEN(@sLastSequenceNo) = 2) THEN LEFT(@sLastSequenceNo, 1) + CHAR(ASCII(RIGHT(@sLastSequenceNo, 1))+1) 
      				    WHEN (ASCII(LEFT(@sLastSequenceNo, 1))  BETWEEN 65 AND 89) AND (ASCII(RIGHT(@sLastSequenceNo, 1)) = 90) THEN CHAR(ASCII(LEFT(@sLastSequenceNo, 1))+1) + 'A'  
      				    WHEN (@sLastSequenceNo = 'ZZ' OR @sLastSequenceNo IS NULL) AND (@bLastStem = 1)  THEN 'A' 
      				    WHEN (@sLastSequenceNo = 'ZZ' OR @sLastSequenceNo IS NULL) AND (@bLastStem = 0)  THEN NULL
      			       END
	
   	-- Use @sFirstGeneratedSequenceis as a flag to check if all of the available Sequence values have already been utilised. 

   	Set @sFirstGeneratedSequence = @sLastSequenceNo

	-- If @sFirstGeneratedSequence is null then set it to '' so REPLACE function can handle it properly. 
	
   	If @sFirstGeneratedSequence is null
   	Begin
    		Set @sFirstGeneratedSequence = ''
   	End

	-- Assemble the TemporaryIRN to check for duplicates in CASES.IRN.
 
        Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sFirstGeneratedSequence)
    		
	-- Generate Next Sequence until the unique value is found, 
	-- wrapping back to the beginning of the sequence range as necessary.	
   
   	While @nErrorCode = 0
	and exists(Select * from CASES where IRN = @sTemporaryIRN)
   	Begin
		-- Store the initial @sLastSequenceNo value in @sLastSequenceNoBefore
		-- to be able to avoid infinite loop.  
		
		Set @sLastSequenceNoBefore = @sLastSequenceNo 
		
   		Set @sLastSequenceNo =  CASE WHEN (ASCII(LEFT (@sLastSequenceNo, 1)) BETWEEN 65 AND 89) AND (LEN(@sLastSequenceNo) = 1) THEN CHAR(ASCII(@sLastSequenceNo)+1) 
       					     WHEN @sLastSequenceNo = 'Z'  THEN 'AA'
       					     WHEN (ASCII(RIGHT(@sLastSequenceNo, 1)) BETWEEN 65 AND 89) AND (LEN(@sLastSequenceNo) = 2) THEN LEFT(@sLastSequenceNo, 1) + CHAR(ASCII(RIGHT(@sLastSequenceNo, 1))+1) 
				             WHEN (ASCII(LEFT(@sLastSequenceNo, 1))  BETWEEN 65 AND 89) AND (ASCII(RIGHT(@sLastSequenceNo, 1)) = 90) THEN CHAR(ASCII(LEFT(@sLastSequenceNo, 1))+1) + 'A'  
				             WHEN (@sLastSequenceNo = 'ZZ' OR @sLastSequenceNo IS NULL) AND (@bLastStem = 1)  THEN 'A' 
				             WHEN (@sLastSequenceNo = 'ZZ' OR @sLastSequenceNo IS NULL) AND (@bLastStem = 0)  THEN NULL 
       				        END

		-- Avoiding infinite loop which may occur when @sLastSequenceNo is null 
		-- and Last Stem does not exists(@bLastStem = 0).  
		
     		Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo is null) and (@sLastSequenceNoBefore is null) THEN 'A'   
         				    ELSE  @sLastSequenceNo 
         			       END
		
		-- If @sLastSequenceNoAfter is null then set it to '' so it can be compared to 
		-- the @sFirstGeneratedSequence and REPLACE function can handle it properly.      	
		
		If @sLastSequenceNo is null
     		Begin
      			Set @sLastSequenceNo = ''
     		End			
			
		-- If all of the available Sequence values have already been utilised then raise an error.

    		If @nErrorCode = 0
		and @sLastSequenceNo = @sFirstGeneratedSequence
    		Begin
     			Set @sAlertXML = dbo.fn_GetAlertXML('CS34', 'Cannot generate Case Reference.  All the Sequence values are in use.',
      							null, null, null, null, null)
     			RAISERROR(@sAlertXML, 14, 1)
     			Set @nErrorCode = @@ERROR
			BREAK
   		End 

    		If @nErrorCode = 0
    		Begin  
     			-- Assemble the TemporaryIRN to check for duplicates in CASES.IRN.

     			Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)
		End
   		Set @nErrorCode = @@ERROR
   	End
  
	-- Load new unique Sequence of 'Nul+ 1Ascending' format.
 
	If @nErrorCode = 0
  	Begin
  		Set @psGeneratedSequence = @sLastSequenceNo
  	End
End

-- Selecting maximum Stem from the CASES table for 'Z&Descending' Sequence. 

If @nErrorCode = 0
and	@pnSequenceType = @nZDescending
Begin 
	-- Get the max Stem from the Cases.Stem where IRN is like PartialCaseReference
	-- with a Sequence of the same format.

	-- If @psStemSegment is not null then there is a "Stem" Segment so look for the 
	-- max Stem first, then for the max Sequence.
	
	If @psStemSegment is null
	Begin 
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)=1"
	End
	Else 
	Begin
		Set @sSQLFilter = "and CHARINDEX('~',C2.STEM)>1"  
	End	

	Set @sSQLString=
   		"set @sMaxStem = (Select  top 1
			CONVERT(NCHAR(30),
    			SUBSTRING(
    			(

			-- Look for the Sequences with the max length first (so Sequence AA would be considered 
			-- being greater then Sequence B).			

			CAST(LEN(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+1), 2)) AS NCHAR(1)) +

			-- Concatenate the max Stem at the end to be able to extract the Last Sequence Generated.  

    			CAST(C1.STEM AS NCHAR(30))),2,30))
     			from CASES C1 
			join CASES C2 on (C1.CASEID=C2.CASEID)" 
			+ @sSQLFilter +
			"where (C1.IRN like @psPartialCaseReference)
			
			-- Ensure that extracted max Stem has Sequence which length is between 1 and 2.

	          	and ( LEN(SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+1), 10)) between 1 and 2 ) 

			-- Filter out any Sequences containing not only A to Z characters.  

	   		and (ASCII(LEFT(SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+1), 2), 1)) between 65 and 90) 
	   	        and (( (ASCII(LEFT(SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+2), 2), 1)) between 65 and 90)) or (LEFT(SUBSTRING(C1.STEM,(CHARINDEX('~', C1.STEM)+2), 2), 1) = ''))
		order by ascii(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+1), 1)) - isnull( ascii(SUBSTRING(C1.STEM, (CHARINDEX('~', C1.STEM)+2), 1)), 0 )
		asc)"  

	exec @nErrorCode=sp_executesql @sSQLString, 
    	 			N'@sMaxStem			nvarchar(30)	 	OUTPUT,
       	  		  	  @psPartialCaseReference	nvarchar(30),
				  @psStemSegment		nvarchar(30)',
       	   		  	  @sMaxStem  			=@sMaxStem 		OUTPUT,
       	   		  	  @psPartialCaseReference      	=@psPartialCaseReference,
				  @psStemSegment		=@psStemSegment	

   	If @nErrorCode = 0
  	Begin
		-- The Last Sequence is found in the Cases.Stem column of previously saved Cases
		-- (already extracted and concatenated at the end of @sMaxStem).

    		Set @sLastSequenceNo = SUBSTRING(@sMaxStem,(CHARINDEX('~', @sMaxStem)+1), 2) 
   	
	End
End

-- 'Z&Descending' Sequence. 

If @nErrorCode = 0
and @pnSequenceType = @nZDescending
Begin
	-- The Next Sequence is loaded into the @sLastSequenceNo variable.
 	
   	Set @sLastSequenceNo = CASE WHEN (ASCII(LEFT (@sLastSequenceNo, 1)) BETWEEN 66 AND 90) AND (LEN(@sLastSequenceNo) = 1) THEN CHAR(ASCII(@sLastSequenceNo)-1) 
      				    WHEN @sLastSequenceNo = 'A'  THEN 'ZZ'
      				    WHEN (ASCII(RIGHT(@sLastSequenceNo, 1)) BETWEEN 66 AND 90) AND (LEN(@sLastSequenceNo) = 2) THEN LEFT(@sLastSequenceNo, 1) + CHAR(ASCII(RIGHT(@sLastSequenceNo, 1))-1) 
      				    WHEN (ASCII(LEFT(@sLastSequenceNo, 1))  BETWEEN 66 AND 90) AND (ASCII(RIGHT(@sLastSequenceNo, 1)) = 65) THEN CHAR(ASCII(LEFT(@sLastSequenceNo, 1))-1) + 'Z'  
      				    WHEN (@sLastSequenceNo = 'AA' or @sLastSequenceNo is null ) THEN 'Z' 
      			       END
	
   	-- Use @sFirstGeneratedSequenceis as a flag to check if all of the available Sequence values have already been utilised. 

   	Set @sFirstGeneratedSequence = @sLastSequenceNo

	-- If @sFirstGeneratedSequence is null then set it to '' so REPLACE function can handle it properly. 
	
   	If @sFirstGeneratedSequence is null
   	Begin
    		Set @sFirstGeneratedSequence = ''
   	End

	-- Assemble the TemporaryIRN to check for duplicates in CASES.IRN.
 
        Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sFirstGeneratedSequence)
    		
	-- Generate Next Sequence until the unique value is found, 
	-- wrapping back to the beginning of the sequence range as necessary.	
   
   	While @nErrorCode = 0
	and exists(Select * from CASES where IRN = @sTemporaryIRN)
   	Begin
		-- Store the initial @sLastSequenceNo value in @sLastSequenceNoBefore
		-- to be able to avoid infinite loop.  
		
		Set @sLastSequenceNoBefore = @sLastSequenceNo 
		
   		Set @sLastSequenceNo =  CASE WHEN (ASCII(LEFT (@sLastSequenceNo, 1)) BETWEEN 66 AND 90) AND (LEN(@sLastSequenceNo) = 1) THEN CHAR(ASCII(@sLastSequenceNo)-1) 
       					     WHEN @sLastSequenceNo = 'A'  THEN 'ZZ'
       					     WHEN (ASCII(RIGHT(@sLastSequenceNo, 1)) BETWEEN 66 AND 90) AND (LEN(@sLastSequenceNo) = 2) THEN LEFT(@sLastSequenceNo, 1) + CHAR(ASCII(RIGHT(@sLastSequenceNo, 1))-1) 
				             WHEN (ASCII(LEFT(@sLastSequenceNo, 1))  BETWEEN 66 AND 90) AND (ASCII(RIGHT(@sLastSequenceNo, 1)) = 65) THEN CHAR(ASCII(LEFT(@sLastSequenceNo, 1))-1) + 'Z'  
      						WHEN (@sLastSequenceNo = 'AA') THEN 'Z' 
       				        END

		-- Avoiding infinite loop which may occur when @sLastSequenceNo is null 
		-- and Last Stem does not exists(@bLastStem = 0).  
		
     		Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo is null) and (@sLastSequenceNoBefore is null) THEN 'Z'   
         				    ELSE  @sLastSequenceNo 
         			       END
		
		-- If @sLastSequenceNoAfter is null then set it to '' so it can be compared to 
		-- the @sFirstGeneratedSequence and REPLACE function can handle it properly.      	
		
		If @sLastSequenceNo is null
     		Begin
      			Set @sLastSequenceNo = ''
     		End			
			
		-- If all of the available Sequence values have already been utilised then raise an error.

    		If @nErrorCode = 0
		and @sLastSequenceNo = @sFirstGeneratedSequence
    		Begin
     			Set @sAlertXML = dbo.fn_GetAlertXML('CS34', 'Cannot generate Case Reference.  All the Sequence values are in use.',
      							null, null, null, null, null)
     			RAISERROR(@sAlertXML, 14, 1)
     			Set @nErrorCode = @@ERROR
			BREAK
   		End 

    		If @nErrorCode = 0
    		Begin  
     			-- Assemble the TemporaryIRN to check for duplicates in CASES.IRN.

     			Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @sLastSequenceNo)
		End
   		Set @nErrorCode = @@ERROR
   	End
  
	-- Load new unique Sequence of 'Nul+ 1Ascending' format.
 
	If @nErrorCode = 0
  	Begin
  		Set @psGeneratedSequence = @sLastSequenceNo
  	End
End

-- 'Roman Numeral' Sequence.

If @nErrorCode = 0
and @pnSequenceType = @nRomanNumeral
Begin
	-- Get the max Stem from the Cases.Stem where IRN is like PartialCaseReference
	-- with a Sequence of the same format.

	-- If @psStemSegment is not null then there is a "Stem" Segment so look for the 
	-- max Stem first and then for the max Sequence else look just for the max Sequence.

	-- Note: Roman Numerals are stored with a preceding R, which must be removed for conversion.

	If @psStemSegment is null
	Begin 
		Set @sSQLFilter = "and CHARINDEX('~',replace( C2.STEM, 'R', ''))=1"
	End
	Else 
	Begin
		Set @sSQLFilter = "and CHARINDEX('~',replace( C2.STEM, 'R', ''))>1"  
	End	

	Set @sSQLString =
			"Select @sMaxStem = max(replace( C2.STEM, 'R', ''))
     			from CASES C1  
			join CASES C2 on (C1.CASEID=C2.CASEID)" 
			+ @sSQLFilter +

			-- Ensure that extracted Sequence is between 01 and 99. 
		
			"and ((CAST(( SUBSTRING(replace( C2.STEM, 'R', ''),(CHARINDEX('~', replace( C2.STEM, 'R', ''))+1), 2) ) as smallint) between 1 and 99))
    			where C1.IRN like @psPartialCaseReference 

			-- Exclude any Sequences containing characters or numbers that are not 
			-- the values from 01 to 99.

			and (ASCII(LEFT(SUBSTRING(replace( C1.STEM, 'R', ''), (CHARINDEX('~', replace( C1.STEM, 'R', ''))+1), 12), 1)) between 48 and 57 ) and (( ASCII(LEFT(SUBSTRING(replace( C1.STEM, 'R', ''), (CHARINDEX('~', replace( C1.STEM, 'R', ''))+2), 12), 1)) between 48 and 57 ) or ( LEFT(SUBSTRING(replace( C1.STEM, 'R', ''), (CHARINDEX('~', replace( C1.STEM, 'R', ''))+2), 12), 1) = ''))

			-- The value '00' is illegal
			and SUBSTRING(replace( C1.STEM, 'R', ''), (CHARINDEX('~', replace( C1.STEM, 'R', ''))+1), 12)<>'00'

			-- Filter out any Sequences which length is not equal to two.			

    			and LEN( SUBSTRING(replace( C1.STEM, 'R', ''),(CHARINDEX('~', replace( C1.STEM, 'R', ''))+1), 2) ) = 2" 

	exec @nErrorCode=sp_executesql @sSQLString, 
    				 N'@sMaxStem			nvarchar(12)	 OUTPUT,
       		  		   @psPartialCaseReference	nvarchar(30),
				   @psStemSegment		nvarchar(12)',
       		   		   @sMaxStem  			=@sMaxStem 	 OUTPUT,
       		   		   @psPartialCaseReference     	=@psPartialCaseReference,
				   @psStemSegment		=@psStemSegment
 
	-- Get the Last Sequence of previously saved Case and generate the Next Sequence.
		
   	If @nErrorCode = 0
   	Begin
		-- The Last Sequence is found in the Cases.Stem column of previously saved Cases
		-- (already extracted and concatenated at the end of @sMaxStem).
		
		Set @sLastSequenceNo = SUBSTRING(@sMaxStem,(CHARINDEX('~', @sMaxStem)+1), 2) 

		-- The Next Sequence is loaded into the @sLastSequenceNo variable.

		Set @sLastSequenceNo = CASE WHEN (@sLastSequenceNo >= '99' OR @sLastSequenceNo IS NULL) then '01'
      				       	    ELSE REPLICATE ('0', 2-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(2))
      				       END 

		-- Use @sFirstGeneratedSequenceis as a flag to check if all of the available Sequence values have already been utilised.

		Set @sFirstGeneratedSequence = @sLastSequenceNo

		-- Get the Roman Numeral equivalent for the generated Sequence
		Set  @psRomanNumeral=dbo.fn_NumberToRoman(cast(@sLastSequenceNo as tinyint))

		-- Assemble the TemporaryIRN to check for duplicates in CASES.IRN.
 
		Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @psRomanNumeral)
   	End
   		
	-- Generate Next Sequence until the unique value is found, 
	-- wrapping back to the beginning of the sequence range as necessary.
	
   	While @nErrorCode = 0 
	and exists(Select * from CASES where IRN = @sTemporaryIRN)  
   	Begin
    		Set @sLastSequenceNo = CASE WHEN @sLastSequenceNo >= '99' then '01'
       					    ELSE REPLICATE ('0', 2-LEN(CAST(@sLastSequenceNo AS INT)+1)) + CAST((CAST(@sLastSequenceNo AS INT)+1) AS NVARCHAR(2))
       				       END 
    		
		-- If all of the available Sequence values have already been utilised then raise an error.

		If @nErrorCode = 0
		and @sLastSequenceNo = @sFirstGeneratedSequence
		Begin
     			Set @sAlertXML = dbo.fn_GetAlertXML('CS34', 'Cannot generate Case Reference. All the Sequence values are in use.',
     							null, null, null, null, null)
     			RAISERROR(@sAlertXML, 14, 1)
     			Set @nErrorCode = @@ERROR
    		End 
			
		-- Insert new Generated Sequence in the @sTemporaryIRN to check for duplicates in CASES.IRN. 

    		If @nErrorCode = 0
    		Begin  

			-- Get the Roman Numeral equivalent for the generated Sequence
			Set  @psRomanNumeral=dbo.fn_NumberToRoman(cast(@sLastSequenceNo as tinyint))

     			Set @sTemporaryIRN = REPLACE (@psPartialCaseReference, '%', @psRomanNumeral)   
    		End
   	End
     			
	-- Load new unique Sequence of '01 Ascending' format. 

	If @nErrorCode = 0
   	Begin
     		Set @psGeneratedSequence = @sLastSequenceNo
       	End
End
	
Return @nErrorCode
GO

Grant execute on dbo.cs_GenerateNextSequence to public
GO
